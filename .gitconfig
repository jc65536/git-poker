[alias]
    # Self explanatory
    all-in = "! \
        git add -A \n \
        git commit \"${@:--m All in.}\" \n \
        git push -f && \n \
        echo 'All in! Remember to rotate your secrets.' #"

    shove = all-in

    # Discard all uncommitted changes
    fold = reset --hard

    # Neutral action
    check = status

    raise = ! git add -A && git commit

    # Betting on top of the big blind is like rebasing on top of another branch.
    # Both can be risky.
    straddle = rebase

    # Pushes all branches
    family-pot = "! \
        git for-each-ref --format='%(refname:short)' refs/heads | \n \
        while read -r head; do \n \
            git switch \"$head\" \n \
            git add -A \n \
            git commit \"$@\" \n \
            git push \n \
        done #"

    # First three commits
    flop = log -n 3

    # Creates a number of commits on the current branch such that the number of
    # commits on this branch is equal to the number of commits on the specified
    # branch. The strategy is to create one commit for each hunk (as defined by
    # `git add --patch`). If there are more than enough hunks, the final commit
    # will contain all the remaining changes. If there aren't enough hunks,
    # empty commits will be created.
    call = "! \
        if (( $# < 1 )); then \n \
            echo \"Usage: git call [commit-options] <branch>\" \n \
            exit 1 \n \
        fi \n \
        new_commit_count=1 \n \
        branch=\"${@: -1}\" \n \
        commit() { \n \
            git commit \"${@:--m Calling $branch #$new_commit_count}\" \n \
        } \n \
        commit_empty() { \n \
            git commit --allow-empty \"${@:--m Calling $branch #$new_commit_count}\" \n \
        } \n \
        git reset \n \
        while true; do \n \
            count_head=\"$(git rev-list --count @)\" \n \
            count_branch=\"$(git rev-list --count \"$branch\")\" \n \
            count_diff=$(( count_branch - count_head )) \n \
            if (( count_diff <= 0 )); then \n \
                break \n \
            elif (( count_diff == 1 )); then \n \
                git add -A \n \
                commit_empty \"${@:1:$# - 1}\" \n \
                break \n \
            else \n \
                files_changed=\"$(git diff --name-only | wc -l)\" \n \
                if (( files_changed == 0 )); then \n \
                    for (( ; count_diff > 0; count_diff -- )); do \n \
                        commit_empty \"${@:1:$# - 1}\" \n \
                        (( new_commit_count++ )) \n \
                    done \n \
                    break \n \
                else \n \
                    echo 'y\nq' | git add --patch > /dev/null 2>&1 \n \
                    commit \"${@:1:$# - 1}\" \n \
                fi \n \
            fi \n \
            (( new_commit_count++ )) \n \
        done #"
